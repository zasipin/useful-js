// // простая вспомогательная функция `bind`

function bind(fn, obj) {
  return function() {
    return fn.apply(obj, arguments);
  };
}

// Еще одной вещью, которую нужно опасаться, является создание (намеренно или нет)
// "косвенных ссылок" на функции, и в этих случаях, когда такая ссылка на функцию вызывается,
// то также применяется правило привязки по умолчанию.

// Самый распространенный путь появления косвенных ссылок — при присваивании:
var a = 2;
var o = { a: 3, foo: foo };
var p = { a: 4 };

o.foo(); // 3
p.foo = o.foo;
p.foo(); // 2

// Смягчение привязки
// Ранее мы отметили, что жесткая привязка была одной из стратегий для предотвращения
// случайного действия правила привязки по умолчанию при вызове функции, заставив ее
// привязаться к указанному this (до тех пор, пока вы не используете new, чтобы переопределить
//   это поведение!). Проблема в том, что жесткая приязка значительно уменьшает гибкость функции,
//    не давая указывать this вручную, чтобы перекрыть неявную привязку или даже последующие
//    попытки явной привязки.

// Было бы неплохо, если бы был путь указать другое умолчание для привязки по умолчанию
// (не global или undefined), но при этом оставив возможность для функции вручную привязать
// this через технику неявной или явной привязки.

// Можно собрать инструмент так называемой мягкой привязки, который эмулирует желаемое поведение.

if (!Function.prototype.softBind) {
  Function.prototype.softBind = function(obj) {
    var fn = this,
      curried = [].slice.call(arguments, 1),
      bound = function bound() {
        return fn.apply(
          !this ||
          (typeof window !== "undefined" && this === window) ||
          (typeof global !== "undefined" && this === global)
            ? obj
            : this,
          curried.concat.apply(curried, arguments)
        );
      };
    bound.prototype = Object.create(fn.prototype);
    return bound;
  };
}
// Инструмент softBind(..), представленный здесь, работает подобно встроенному в ES5 инструменту bind(..),
// за исключением нашего поведения мягкой привязки. Он делает обертку указанной функции с логикой,
// которая проверяет this в момент вызова и если это global или undefined, использует указанное заранее
// альтернативное умолчание (obj). В противном случае this остается как есть. Также этот инструмент дает
// возможность опционального карринга (см. ранее обсуждениеbind(..)).

// Продемонстрируем его в действии:

function foo() {
  console.log("name: " + this.name);
}

var obj = { name: "obj" },
  obj2 = { name: "obj2" },
  obj3 = { name: "obj3" };

var fooOBJ = foo.softBind(obj);

fooOBJ(); // name: obj

obj2.foo = foo.softBind(obj);
obj2.foo(); // name: obj2   <---- смотрите!!!

fooOBJ.call(obj3); // name: obj3   <---- смотрите!

setTimeout(obj2.foo, 10); // name: obj   <---- возврат к мягкой привяке

// Для мягкопривязанной версии функции foo() можно вручную привязать this к obj2 или obj3 как показано выше,
// но он возвращается к obj в случае применения привязки по умолчанию.
